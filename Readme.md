# Database-service

## Задание

Создайте высоконагруженное приложение на Golang, которое будет предоставлять кешированный доступ на чтение к данным из
базы данных Postgresql.

### Требования

1. Структура бд. Таблица users содержит информацию о пользователях и их уровне доступа(user или admin). Таблица data
   содержит сами данные, к которым предоставляется доступ, а также информацию о том, какому пользователю они
   принадлежат.
2. Схема - на свое усмотрение.
3. Формат API - свободный.
4. Приложение должно быть способно обрабатывать большое количество запросов одновременно. (> 100 RPS)
5. Приложение должно использовать кеширование для ускорения доступа к данным. Однако при изменении данных в базе данных
   через какое-то время данные должны обновляться
6. Приложение должно обеспечивать контроль доступа. user должен иметь доступ только в своим данным, а admin - ко всем.
   Вы можете использовать любую библиотеку для аутентификации и авторизации на ваш выбор.
7. Приложение должно поставляться в виде docker-compose файла. Вы должны предоставить инструкции по запуску приложения с
   помощью Docker.
8. Напишите тесты для вашего приложения. Вы можете использовать любую библиотеку для тестирования на ваш выбор.
9. Код должен быть хорошо структурирован и легко читаем. Вы должны следовать принципам чистого кода и использовать
   паттерны проектирования, где это необходимо.
10. Приложение должно быть готово к продакшену. Это означает, что оно должно быть стабильным, надежным и безопасным.
11. (Опционально) Предоставьте документацию для вашего приложения. Документация должна включать описание
    функциональности приложения, инструкции по запуску и использованию приложения, а также описание архитектуры
    приложения.

## Установка
* Спуллить проект
* Запустить файл `bootstrap.sh`. Это раскомментирует все примеры конфигов.
* Запустить отдельно контейнер с postgres и дождаться старта базы данных `docker compose up postgres`
* Запустить остальные сервисы `docker compose up`

Если вы хотите заполнить таблицы тестовыми данными, раскомментируйте в файле `docker-compose.yml` сервис create_data, и запустите его. Он сгенерирует 500 000 пользователей, и каждому по 20 data.
Либо, вы можете изменить подключение в файле утилиты, скомпилировать ее, и запустить с нужными флагами.


## База данных

### Миграции

Для миграций используется утилита [goose](https://github.com/pressly/goose). 

Миграции расположены в каталоге /migrations, и будут применены при запуске `docker compose`

### Структура бд

#### users
| Name         |             Type              |     Comment     |
|:-------------|:-----------------------------:|:---------------:|
| Id           |         PK, BIGSERIAL         | Первичный ключ  |
| access_level | access_level(*user*\|*admin*) | Уровень доступа |

#### data
| Name    |      Type      |        Comment        |
|:--------|:--------------:|:---------------------:|
| Id      | PK, BIGSERIAL  |    Первичный ключ     |
| user_id | FK к __users__ | Связь с пользователем |
| data    |      TEXT      |  Данные пользователя  |

## Описание приложения

[Спецификация](api-specification.yaml)

Приложение - это апи, имеющее метод GET /data. Этот метод возвращает данные из таблицы дата, основываясь на уровне доступа запросившего пользователя.
Если пользователь имеет уровень доступа "admin", метод вернет все записи из таблицы, если же нет, то вернет только те записи, которые принадлежат пользователю.

Пользователь определяется с помощью Bearer JWT-токена, указанного в заголовке Authorization. Сгенерировать такой токен можно, если скомпилировать и запустить утилиту token_generator. Или можете использовать мой, user_id - 100
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMDB9.JgHrq72KplDTkhNrMFb2a-Mid_cDN2f9RLrEZ__K_p4
```

Метод использует кеширование при доступе к данным. Если обращается пользователь, будут закешированы только его данные. Запрос с уровнем доступа "admin" не кеширует собственные данные, но переписывает кеш для пользователей, данные которых он запросил.

Код приложения расположен в каталоге dbservice.

### Конфигурация

#### ENV

CONFIG_PATH - Путь до конфига внутри приложения. По умолчанию "./config/database-service/config.yaml".

#### YML

```yml
jwt_code_phrase: "example-phrase" // секретная фраза подписи JWT для расшифровки токенов
cache: // параметры кеша, время его жизни и префикс ключей
  ttl: 1000
  key_prefix: "database-service"
db: // подключение к бд
  host: "postgres"
  port: "5432"
  username: "database-service"
  password: "password"
  database: "users_data"
redis: // подключение к редису
  addr: "redis:6379"
  db: 0
  username: "database-service"
  password: "password"
```

## Утилиты

### Create_data
Создает пользователей и data для теста. Имеет следующие флаги:
* `-users` - общее количество генерируемых записей пользователей
* `-data` - количество данных, которое будет сгенерировано на одного пользователя
* `-workers` - количество воркеров для запросов к базе. 

### Load_generator
Генератор запросов. Старается обеспечить заданное количество запросов в секунду. Создает воркеров в указанном количестве, каждый воркер отправляет раз в секунду запрос. Время от времени падает из-за того, что занял все коннекты в сокете. Решил проблему добавив свойство `restart: always`
Имеет следующие флаги:
* `-rps` - количество запросов в секунду
* `-host` - хост, на который нужно кидать запрос

### Token_generator
Генерирует токены пользователей. Имеет следующие флаги:
* `-userId` - идентификатор пользователя
* `-phrase` - секретная фраза для шифрования

## Комментарий

### Про архитектуру
В разработке я старался придерживаться гексагональной архитектуры. Поэтому под каждый чих в приложении определено по интерфейсу и минимум по одной реализации. 
Приложение разделено на слои -

* Слой контроллеров берет необходимые данные из запроса и оправляет их в сервисы
* Слой сервисов - на нем находится бизнес логика.
* Слой данных - все манипуляции с данными проходят через него.

Обычно в подобных приложениях для переноса данных между слоями используется DTO. Но я решил не придерживаться этой концепции ввиду общей простоты сервиса.

### Про тесты
Тесты под капотом используют библиотеку testcontainers. Она позволяет запускать контейнеры во время тестов, а так же самостоятельно их убивает по окончанию.

Все участвующие в тестах данные, такие как пользователь, репозитории, сервисы и тд сосредоточены в suite.
Перед запуском тестов, все они возвращаются в нормальное состояние. Под таким состоянием понимается состояние, которое позволяет провести успешный прогон по методу.
После выполнения теста удаляем сгенерированные им данные из всех баз.

Далее, уже в самом тесте, при вызове suite.build() вернется контроллер, в свойствах которого уже будут находится стабы. Стабы можно как угодно изменять до вызова этой функции, все изменения будут в контроллере.

С таким бойлерплейтом тесты позволяют проверять любой, даже самый точечный кейс, при этом не читают в читабельности.

### Про rpsы
Для подсчета количества RPS использовался prometheus + load_generator. 
Система - AMD Ryzen 5800X + 32gb оперативной памяти. 

По итогу, после часа тестов, получился результат >500
![img.png](img.png)